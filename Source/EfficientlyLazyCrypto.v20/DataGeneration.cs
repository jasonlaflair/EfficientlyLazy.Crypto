using System;
using System.Collections.Generic;
using System.Security.Cryptography;

namespace EfficientlyLazyCrypto
{
   /// <summary>
   /// Generation of true random data.
   /// </summary>
   public static class DataGeneration
   {
      private const int MAXITERATIONS = 1000;

      private static readonly SortedList<int,int> _usedSeedValues = new SortedList<int,int>();

      /// <summary>
      /// Generates a random seed value.
      /// </summary>
      /// <returns>A random seed value as <see cref="int"/>.</returns>
      /// <remarks>Generated by using the <see cref="RNGCryptoServiceProvider"/> and can be used as a stronger seed value to <see cref="System.Random"/>.</remarks>
      public static int RandomSeedValue()
      {
         // We will make up an integer seed from 4 bytes of this array.
         var randomBytes = new byte[4];

         // Generate 4 random bytes.
         var rng = new RNGCryptoServiceProvider();

         int seed = 0;
         bool valid = false;

         while(!valid)
         {
            rng.GetBytes(randomBytes);

            // Convert four random bytes into a positive integer value.
            seed = ((randomBytes[0] & 0x7f) << 24) | (randomBytes[1] << 16) | (randomBytes[2] << 8) | (randomBytes[3]);

            if(_usedSeedValues.ContainsKey(seed))
               continue;

            _usedSeedValues.Add(seed,seed);
            valid = true;
         }

         return seed;
      }

      /// <summary>
      /// Generates a random <see cref="int"/>.
      /// </summary>
      /// <param name="minValue">Minimum value (inclusive).</param>
      /// <param name="maxValue">Maximum value (inclusive).</param>
      /// <returns>Random <see cref="int"/> value between the <paramref name="minValue"/> and <paramref name="maxValue"/> (inclusive).</returns>
      /// <remarks>
      /// This methods overcomes the limitations of .NET Framework's Random
      /// class, which - when initialized multiple times within a very short
      /// period of time - can generate the same "random" number.
      /// </remarks>
      /// <exception cref="ArgumentOutOfRangeException"><c>maxValue</c> is out of range.</exception>
      public static int RandomInteger(int minValue,int maxValue)
      {
         if(minValue > maxValue)
            throw new ArgumentOutOfRangeException("maxValue","maxValue must be greater than or equal to minValue");

         var random = new Random(RandomSeedValue());
         return random.Next(minValue,maxValue);
      }

      /// <summary>
      /// Generates random data.
      /// </summary>
      /// <param name="minLength">Minimum length of the returned value.</param>
      /// <param name="maxLength">Maximum length of the returned value.</param>
      /// <param name="characterSets">A <see cref="IList{T}"/> of <see cref="CharacterSet"/> to generate the random data from.</param>
      /// <returns>Random data, as a <see cref="string"/>, based on the specified criteria.</returns>
      /// <exception cref="ArgumentOutOfRangeException"><c>maxLength</c> is out of range.</exception>
      /// <exception cref="ArgumentOutOfRangeException"><c>minLength</c> is out of range.</exception>
      /// <exception cref="ArgumentOutOfRangeException"><c>characterSets</c> is out of range.</exception>
      /// <exception cref="ArgumentOutOfRangeException"><c>characterSets</c> overlap.</exception>
      /// <exception cref="InvalidOperationException"><c>InvalidOperationException</c>.</exception>
      public static string RandomString(int minLength,int maxLength,IList<CharacterSet> characterSets)
      {
         if(minLength > maxLength)
         {
            throw new ArgumentOutOfRangeException("maxLength","maxLength must be greater than or equal to minLength");
         }

         if(minLength <= 0)
         {
            throw new ArgumentOutOfRangeException("minLength",minLength,"minLength must be greater than 0");
         }

         if(characterSets == null || characterSets.Count == 0)
         {
            throw new ArgumentOutOfRangeException("characterSets","Empty character set");
         }

         List<char> masterCharacterPool = new List<char>();

         foreach(CharacterSet set in characterSets)
         {
            foreach(char ch in set.Characters)
            {
               if(masterCharacterPool.Contains(ch))
               {
                  throw new ArgumentOutOfRangeException("characterSets",
                                                        "CharacterSets contact overlapping characters");
               }

               masterCharacterPool.Add(ch);
            }
         }

         Random random = new Random(RandomSeedValue());

         // randomize masterCharacterPool
         for(int randomPasses = 0;randomPasses <= 2;randomPasses++)
         {
            for(int idx = masterCharacterPool.Count - 1;idx > 0;--idx)
            {
               int tempPosition = random.Next(idx);
               char tempChar = masterCharacterPool[idx];
               masterCharacterPool[idx] = masterCharacterPool[tempPosition];
               masterCharacterPool[tempPosition] = tempChar;
            }
         }

         List<char> results = new List<char>();
         int currentIteration = 0;

         Dictionary<CharacterSet,bool> requirementsMet = new Dictionary<CharacterSet,bool>();
         foreach(CharacterSet set in characterSets)
         {
            requirementsMet.Add(set,set.MinimumRequired == 0);
         }

         bool areRequirementsMet = false;

         while(!areRequirementsMet)
         {
            currentIteration++;

            if(currentIteration > MAXITERATIONS)
            {
               throw new InvalidOperationException(string.Format("Generation iterations exceeded ({0}).",MAXITERATIONS));
            }

            int length = random.Next(minLength,maxLength);

            results = new List<char>();

            for(int i = 0;i < length;i++)
            {
               char randomChar = masterCharacterPool[random.Next(0,masterCharacterPool.Count - 1)];

               results.Add(randomChar);
            }

            foreach(CharacterSet set in characterSets)
            {
               if(set.MinimumRequired == 0)
                  continue;

               int found = 0;

               foreach(char ch in set.Characters)
               {
                  if(results.Contains(ch))
                     found++;
               }

               requirementsMet[set] = found >= set.MinimumRequired;
            }

            areRequirementsMet = true;

            foreach(var pair in requirementsMet)
            {
               if(!pair.Value)
                  areRequirementsMet = false;
            }
         }

         string returnValue = string.Empty;

         results.ForEach(ch => returnValue += ch.ToString());

         return returnValue;
      }

      ///<summary>
      /// Generates random data.
      ///</summary>
      /// <param name="minLength">Minimum length of the returned value.</param>
      /// <param name="maxLength">Maximum length of the returned value.</param>
      /// <returns>Random data, as a <see cref="string"/>, based on the specified criteria.</returns>
      public static string RandomString(int minLength,int maxLength)
      {
         return RandomString(minLength,maxLength,new List<CharacterSet>
                                                    {
                                                        CharacterSet.AllLowercase(),
                                                        CharacterSet.AllUppercase(),
                                                        CharacterSet.AllNumeric(),
                                                        CharacterSet.AllSpecial()
                                                    });
      }

      ///<summary>
      /// Generates random data.
      ///</summary>
      /// <param name="minLength">Minimum length of the returned value.</param>
      /// <param name="maxLength">Maximum length of the returned value.</param>
      ///<param name="includeUppers"></param>
      ///<param name="includeLowers"></param>
      ///<param name="includeNumbers"></param>
      ///<param name="includeSpecials"></param>
      /// <returns>Random data, as a <see cref="string"/>, based on the specified criteria.</returns>
      public static string RandomString(int minLength,int maxLength,bool includeUppers,bool includeLowers,bool includeNumbers,bool includeSpecials)
      {
         List<CharacterSet> characterSets = new List<CharacterSet>();

         if(includeUppers)
            characterSets.Add(CharacterSet.AllUppercase());
         if(includeLowers)
            characterSets.Add(CharacterSet.AllLowercase());
         if(includeNumbers)
            characterSets.Add(CharacterSet.AllNumeric());
         if(includeSpecials)
            characterSets.Add(CharacterSet.AllSpecial());

         return RandomString(minLength,maxLength,characterSets);
      }

      ///<summary>
      /// Generates random data.
      ///</summary>
      /// <param name="minLength">Minimum length of the returned value.</param>
      /// <param name="maxLength">Maximum length of the returned value.</param>
      ///<param name="requiredUppers"></param>
      ///<param name="requiredLowers"></param>
      ///<param name="requiredNumerics"></param>
      ///<param name="requiredSpecials"></param>
      /// <returns>Random data, as a <see cref="string"/>, based on the specified criteria.</returns>
      public static string RandomString(int minLength,int maxLength,int requiredUppers,int requiredLowers,int requiredNumerics,int requiredSpecials)
      {
         return RandomString(minLength,maxLength,new List<CharacterSet>
                                                    {
                                                        CharacterSet.AllLowercase(requiredLowers),
                                                        CharacterSet.AllUppercase(requiredUppers),
                                                        CharacterSet.AllNumeric(requiredNumerics),
                                                        CharacterSet.AllSpecial(requiredSpecials)
                                                    });
      }

      ///<summary>
      /// Generates random data.
      ///</summary>
      /// <param name="minLength">Minimum length of the returned value.</param>
      /// <param name="maxLength">Maximum length of the returned value.</param>
      ///<param name="requiredUppers"></param>
      ///<param name="requiredLowers"></param>
      ///<param name="requiredNumerics"></param>
      ///<param name="requiredSpecials"></param>
      /// <returns>Random data, as a <see cref="string"/>, based on the specified criteria.</returns>
      public static string RandomString(int minLength,int maxLength,int? requiredUppers,int? requiredLowers,int? requiredNumerics,int? requiredSpecials)
      {
         List<CharacterSet> characterSets = new List<CharacterSet>();

         if(requiredUppers.HasValue)
            characterSets.Add(CharacterSet.AllUppercase(requiredUppers.Value));
         if(requiredLowers.HasValue)
            characterSets.Add(CharacterSet.AllLowercase(requiredLowers.Value));
         if(requiredNumerics.HasValue)
            characterSets.Add(CharacterSet.AllNumeric(requiredNumerics.Value));
         if(requiredSpecials.HasValue)
            characterSets.Add(CharacterSet.AllSpecial(requiredSpecials.Value));

         return RandomString(minLength,maxLength,characterSets);
      }
   }
}