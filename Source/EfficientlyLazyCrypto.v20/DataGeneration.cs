using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;

namespace EfficientlyLazyCrypto
{
    /// <summary>
    /// Generation of true random data.
    /// </summary>
    public static class DataGeneration
    {
        private const int MAXITERATIONS = 1000;

        private static double _usedSeedValueClearThreshold = 0.60;
        ///<summary>
        ///</summary>
        ///<exception cref="InvalidOperationException"></exception>
        public static double UsedSeedValueClearThreshold
        {
            get { return _usedSeedValueClearThreshold; }
            set
            {
                if (_usedSeedValueClearThreshold >= 1 || _usedSeedValueClearThreshold <= 0)
                {
                    throw new InvalidOperationException("UsedSeedValueClearThreshold must be expressed as a decimal less than 1 and greater than 0");
                }

                _usedSeedValueClearThreshold = value;
            }
        }
        private static readonly List<int> _usedSeedValues = new List<int>();

        /// <summary>
        /// Generates a random seed value.
        /// </summary>
        /// <returns>A random seed value as <see cref="int"/>.</returns>
        /// <remarks>Generated by using the <see cref="RNGCryptoServiceProvider"/> and can be used as a stronger seed value to <see cref="System.Random"/>.</remarks>
        public static int RandomSeedValue()
        {
            // We will make up an integer seed from 4 bytes of this array.
            var randomBytes = new byte[4];

            // Generate 4 random bytes.
            var rng = new RNGCryptoServiceProvider();

            int seed = 0;
            bool valid = false;

            while (!valid)
            {
                rng.GetBytes(randomBytes);

                // Convert four random bytes into a positive integer value.
                seed = ((randomBytes[0] & 0x7f) << 24) | (randomBytes[1] << 16) | (randomBytes[2] << 8) | (randomBytes[3]);

                if (_usedSeedValues.Contains(seed))
                    continue;

                int index = _usedSeedValues.BinarySearch(seed);
                _usedSeedValues.Insert(~index, seed);

                valid = true;
            }

            // clear out the list to aid in performance
            if (_usedSeedValues.Count > (int.MaxValue * _usedSeedValueClearThreshold))
            {
                _usedSeedValues.Clear();
            }

            return seed;
        }

        /// <summary>
        /// Generates a random <see cref="int"/>.
        /// </summary>
        /// <param name="minValue">Minimum value (inclusive).</param>
        /// <param name="maxValue">Maximum value (inclusive).</param>
        /// <returns>Random <see cref="int"/> value between the <paramref name="minValue"/> and <paramref name="maxValue"/> (inclusive).</returns>
        /// <remarks>
        /// This methods overcomes the limitations of .NET Framework's Random
        /// class, which - when initialized multiple times within a very short
        /// period of time - can generate the same "random" number.
        /// </remarks>
        /// <exception cref="ArgumentOutOfRangeException"><c>maxValue</c> is out of range.</exception>
        public static int RandomInteger(int minValue, int maxValue)
        {
            if (minValue > maxValue)
                throw new ArgumentOutOfRangeException("maxValue", "maxValue must be greater than or equal to minValue");

            var random = new Random(RandomSeedValue());
            return random.Next(minValue, maxValue);
        }

        ///<summary>
        ///</summary>
        ///<param name="requirements"></param>
        ///<returns></returns>
        ///<exception cref="InvalidOperationException"></exception>
        public static string RandomString(RandomStringRequirements requirements)
        {
            List<char> masterCharacterPool = new List<char>();

            foreach (CharacterSet set in requirements.CharacterSets)
            {
                foreach (char ch in set.Characters)
                {
                    masterCharacterPool.Add(ch);
                }
            }

            Random random = new Random(RandomSeedValue());

            // randomize masterCharacterPool
            for (int randomPasses = 0; randomPasses <= 4; randomPasses++)
            {
                for (int idx = masterCharacterPool.Count - 1; idx > 0; --idx)
                {
                    int tempPosition = random.Next(idx);
                    char tempChar = masterCharacterPool[idx];
                    masterCharacterPool[idx] = masterCharacterPool[tempPosition];
                    masterCharacterPool[tempPosition] = tempChar;
                }
            }

            bool requirementsMet = false;
            int currentIteration = 0;

            StringBuilder results = new StringBuilder();

            while (!requirementsMet)
            {
                currentIteration++;
                if (currentIteration >= MAXITERATIONS)
                {
                    throw new InvalidOperationException(string.Format("unable to create required random string in {0} iterations", currentIteration));
                }

                int length = random.Next(requirements.MinimumLength, requirements.MaximumLength);
                results = new StringBuilder();
                
                for (int i = 0; i < length; i++)
                {
                    char randomChar = masterCharacterPool[random.Next(0, masterCharacterPool.Count - 1)];
                    results.Append(randomChar);
                }

                requirements.CharacterSets.ForEach(set => set.ResetFindings());

                for (int i = 0; i < results.Length; i++)
                {
                    char ch = results[i];

                    foreach (CharacterSet set in requirements.CharacterSets)
                    {
                        if (!set.Characters.Contains(ch)) continue;

                        set.CharacterFound();
                        break;
                    }
                }

                requirementsMet = true;

                foreach (CharacterSet set in requirements.CharacterSets)
                {
                    if (set.RequirementsMet) continue;
                    
                    requirementsMet = false;
                    break;
                }
            }

            return results.ToString();
        }

        ///<summary>
        ///</summary>
        ///<param name="minLength"></param>
        ///<param name="maxLength"></param>
        ///<returns></returns>
        public static string RandomString(int minLength, int maxLength)
        {
            return RandomString(minLength, maxLength, true, true, true, true);
        }

        ///<summary>
        ///</summary>
        ///<param name="minLength"></param>
        ///<param name="maxLength"></param>
        ///<param name="includeLowers"></param>
        ///<param name="includeUppers"></param>
        ///<param name="includeNumeric"></param>
        ///<param name="includeSpecials"></param>
        ///<returns></returns>
        ///<exception cref="ArgumentException"></exception>
        public static string RandomString(int minLength, int maxLength, bool includeLowers, bool includeUppers, bool includeNumeric, bool includeSpecials)
        {
            if (!includeLowers && !includeUppers && !includeNumeric && !includeSpecials)
            {
                throw new ArgumentException("At least one character set is required");
            }

            RandomStringRequirements requirements = new RandomStringRequirements(minLength, maxLength);

            if (includeLowers) requirements.AddCharacterSet(CharacterSet.AllLowercase());
            if (includeUppers) requirements.AddCharacterSet(CharacterSet.AllUppercase());
            if (includeNumeric) requirements.AddCharacterSet(CharacterSet.AllNumeric());
            if (includeSpecials) requirements.AddCharacterSet(CharacterSet.AllSpecial());

            return RandomString(requirements);
        }
    }
}